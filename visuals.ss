
(define (pretty-board-state board*)
  (display-fragments
   (map (lambda (c.id)
          (case (cdr c.id)
            ((A) `(,@(huge-card (car c.id))
                   ,(make-string 7 #\space)))
            ((B) `(,(make-string 7 #\space)
                   ,@(huge-card (car c.id))))))
        board*))
  (newline))

;;; progress bar when comparing agents
(define (display-progress-bar A B N)
  (let ((progress (ceiling (* 100 (/ (+ A B) N))))
        (bar-A (round (/ (* 100 A) N)))
        (bar-B (round (/ (* 100 B) N))))
    (display #\[)
    (display-with-foreground 'light-green (make-string bar-A #\~))
    (display-with-foreground 'light-red (make-string (- 100 bar-A bar-B) #\?))    
    (display-with-foreground 'light-cyan (make-string bar-B #\~))
    (display-ln #\])))

(define (simple-progress-bar name i N)
  (for-all (lambda (n)
             (newline))
           (iota 40))
  (let ((progress (round (/ (* 100 i) N))))
    (display-with-foreground 'light-cyan name)
    (display #\[)
    (display-with-foreground 'light-green (make-string progress #\~))
    (display-with-foreground 'light-red (make-string (- 100 progress) #\.))    
    (display-ln #\])))

;;; render board for terminal
(define (display-cribbage-state player state phase)
  (let ((status (case (crib-dealer state)
                  ((A) 'pone)
                  ((B) 'deal))))
    (for-all (lambda (n) (newline)) (iota 30))
    (case phase
      ((discard)
       (format #t "~a~%~a ~a~%" status (crib-scoreB state) (crib-scoreA state))
       (newline)
       (display-huge-hand (crib-handB state))
       (newline))
      ((peg)
       (pretty-board-state (crib-board* state))
       (format #t "~a~%~a ~a~%" status (crib-scoreB state) (crib-scoreA state))
       (display-huge-hand (list (crib-cut state)))
       (display-huge-hand (crib-board state))
       (format #t "~%board count ~a~%" (crib-board-total (crib-board state)))
       (display-huge-hand (crib-handB state)))
      ((count)
       (let ((cut-card (crib-cut state))
             (handA (board*->hand state 'A))
             (handB (board*->hand state 'B))
             (crib (crib-crib state)))
         (let ((ordered-hands (if (eq? player (crib-dealer state))
                                  (list handA handB)
                                  (list handB handA))))
           (pretty-board-state (crib-board* state))
           (display-huge-hand (list cut-card))
           (for-all (lambda (hand)
                      (newline)
                      (display-huge-hand hand)
                      (format #t "scores ~a~%~%"
                              (score-hand (cons cut-card hand))))
                    ordered-hands)
           (newline)
           (display-huge-hand crib)
           (format #t "scores ~a~%~%" (score-crib (cons cut-card crib)))
           (format #t "~%B.C. ~a ~a~%" (crib-scoreB state) (crib-scoreA state))
           (format #t "Enter anything to continue~%")
           (read))))
      ((won)
       (format #t "Game over! ~a ~a~%" (crib-scoreB state) (crib-scoreA state))))))
